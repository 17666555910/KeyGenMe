
> 我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到时间、空间复杂度分析。

# 1、什么是复杂度分析？
> 复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。

# 2、为什么需要进行复杂度分析？
最主要的原因就是事后统计法有非常大的局限性，主要表现在
- **测试结果非常依赖测试环境**
>测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用 Intel Core i7 处理器和 Intel Core i3 处理器来运行，不用说，i7 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。
- **测试结果受数据规模的影响很大**
>对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！

PS：我们把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小这种方式称为事后统计法。

# 3、时间复杂度详解
>时间复杂度又叫做渐进式时间复杂度。我们通常通过大 O 复杂度表示法来表示时间复杂度。在使用大O表示法时，我们可以忽略其低阶、常量、系数，则只需要关注循环执行次数最多的一段代码。

时间复杂度可以分为7中类型，分别是：
- O(1): 常数复杂度（常数阶）
- O(log n): 对数复杂度（对数阶）
- O(n): 线性时间复杂度（线性阶）
- O(n log n)：线性对数复杂度（线性对数阶）
- O(n^2)：平方、O(n^3): 立方、O(n^k): k次方（k次方阶）
- O(2^n): 指数（指数阶）
- O(n!): 阶乘（阶乘阶）

其中O(1)、O(log n)、O(n)、O(n^2)、O(n log n)、O(n^2)为**多项式阶级**；O(2^n)、O(n!)为**非多项式阶级**。当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，我们主要来看几种常见的多项式时间复杂度。

## 3.1、O(1) 常数阶
只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

```
 int i = 8;
 int j = 6;
 int sum = i + j;
```



## 3.2、O(log n) 对数阶
指的是代码的执行次数成对数方式递增，如下代码

```
i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。实际上，变量 i 的取值就是一个等比数列。所以，这段代码的时间复杂度就是 O(log2n)，即为O(log n)。

## 3.3、O(n) 线性阶
指的是代码的执行次数成线性递增，如下代码

```
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```


由代码我们可以看出在代码中2、3行只会执行一次，则他们的时间复杂度就是O(1)，第4、5行执行n次，即时间复杂度为O(2n)，总的时间复杂度为O(1+2n)，由于**在计算时间复杂度时只关注循环次数最多的代码，并使用大O表示法时可以忽略其低阶、常量、系数**，则最终的时间复杂度为O(n)。

## 3.4、O(n log n) 线性对数阶
如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，**O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)**。

```
for (int i = 0; i < n; i++) {
    i=1;
    while (i <= n)  {
        i = i * 2;
    }
}
```
## 3.5 O(n^k) 次方阶 如n^2 平方、n^3 立方
```
void cal(int n) {
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 }
```
## 3.6、分析一段代码时间复杂度的三种方法
### 3.6.1 只关注循环执行次数最多的一段代码
大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，**我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。
### 3.6.2 加法法则：总复杂度等于量级最大的那段代码的复杂度

```
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```
这个代码分为三部分，分别是求 sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。

第一段的时间复杂度是多少呢？这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。

这里我要再强调一下，即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。

那第二段代码和第三段代码的时间复杂度是多少呢？答案是 O(n) 和 O(n2)，你应该能容易就分析出来，我就不啰嗦了。

综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n2)。也就是说：**总的时间复杂度就等于量级最大的那段代码的时间复杂度**。
### 3.6.3 多数据规模的时间复杂度
我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！
```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```
> 从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。

# 4、空间复杂度
> 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。我们常见的空间复杂度就是 O(1)、O(n)、O(n^2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。

具体的例子如下
```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    System.out.println(a[i]);
  }
}
```
跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。



# 5、为什么说性能测试和时间、空间复杂度不冲突？
由于做一个性能测试测试结果会受到数据规模测试机器等外界因素的影响，所以性能测试不是很具有代表性，但是时间复杂度和空间复杂度分析是比较客观的，不会受到外界因素的影响，只有先做了复杂度分析我们才能确实最优方案，最后得到最优解才开始做性能测试。 渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。